<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>a145789</title>
    <script type="module" crossorigin="" src="/aboutme/assets/app-COJWMJCj.js"></script>
    <link rel="stylesheet" crossorigin="" href="/aboutme/assets/app-DZDWi8WY.css">
  <link rel="modulepreload" crossorigin="" href="/aboutme/assets/_id_-RmZ7e6o5.js"><link rel="stylesheet" href="/aboutme/assets/_id_-BtHzYGCi.css"></head>
  <body>
    <div id="app" data-server-rendered="true"><main class="mx-auto w-full p-4 md:max-w-[56%] md:p-8"><div><div><p class="text-2xl font-bold">nextTick 原理及使用</p><p class="text-sm font-bold">2023/04/03 15:20</p><hr><div class="my-markdown"><h1>nextTick 作用</h1>
<p><code>vue</code> 官网对 <a href="https://cn.vuejs.org/api/general.html#nexttick" target="_blank" rel="noopener noreferrer">nextTick</a> 的介绍为 <strong>等待下一次 <code>DOM</code> 更新刷新的工具方法</strong>。首先什么是 <code>DOM</code> 更新。</p>
<h2>Dom 更新</h2>
<pre class="shiki shiki-themes Lambda Studio — Whiteout" style="background-color:#fff;color:#000" tabindex="0"><code class="language-js"><span class="line"><span style="color:#000">document</span><span style="color:#0008">.</span><span style="color:#000">querySelector</span><span style="color:#0008">(</span><span style="color:#0008">'div'</span><span style="color:#0008">).</span><span style="color:#000">innerHTML </span><span style="color:#0008">=</span><span style="color:#0008"> 'Dom 更新'</span></span>
<span class="line"><span style="color:#000">console</span><span style="color:#0008">.</span><span style="color:#000">log</span><span style="color:#0008">(</span><span style="color:#000">document</span><span style="color:#0008">.</span><span style="color:#000">querySelector</span><span style="color:#0008">(</span><span style="color:#0008">'div'</span><span style="color:#0008">).</span><span style="color:#000">innerHTML</span><span style="color:#0008">)</span><span style="color:#0008"> //</span><span style="color:#0004"> 会输出 Dom 更新</span></span></code></pre>
<p><code>Dom</code> 更新需要先对 <code>Dom</code> 对象上的属性做修改，例如修改某个节点 <code>innerHTML</code>，这一步是同步的，然后浏览器会异步更新 <code>DOM</code>。但对于 <code>Vue</code> 而言，响应式更新帮我们隐去了这一步。</p>
<pre class="shiki shiki-themes Lambda Studio — Whiteout" style="background-color:#fff;color:#000" tabindex="0"><code class="language-html"><span class="line"><span style="color:#0008">&lt;</span><span style="color:#000">template</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">  &lt;</span><span style="color:#000">div </span><span style="color:#0008">class=</span><span style="color:#0008">"aka"</span><span style="color:#0008">&gt;</span><span style="color:#000">{{a}}</span><span style="color:#0008">&lt;/</span><span style="color:#000">div</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">  &lt;</span><span style="color:#000">button </span><span style="color:#0008">@click=</span><span style="color:#0008">"fn"</span><span style="color:#0008">&gt;</span><span style="color:#000">click</span><span style="color:#0008">&lt;/</span><span style="color:#000">button</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">&lt;/</span><span style="color:#000">template</span><span style="color:#0008">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0008">&lt;</span><span style="color:#000">script </span><span style="color:#0008">setup&gt;</span></span>
<span class="line"><span style="color:#0008">  const</span><span style="color:#000"> a </span><span style="color:#0008">=</span><span style="color:#000"> ref</span><span style="color:#0008">(</span><span style="color:#0008">''</span><span style="color:#0008">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0008">  function</span><span style="color:#000;--shiki-light-font-weight:bold"> fn</span><span style="color:#0008">()</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#000">    a</span><span style="color:#0008">.</span><span style="color:#000">value </span><span style="color:#0008">=</span><span style="color:#0008"> 'Dom 更新'</span></span>
<span class="line"><span style="color:#0008">  }</span></span>
<span class="line"><span style="color:#0008">&lt;/</span><span style="color:#000">script</span><span style="color:#0008">&gt;</span></span></code></pre>
<p>每次点击 <code>button</code> 更改 <code>a.value</code> 就会触发 <code>Dom</code> 更新。但如上文更改 <code>Dom</code> 属性是同步的，倘若代码是这样的</p>
<pre class="shiki shiki-themes Lambda Studio — Whiteout" style="background-color:#fff;color:#000" tabindex="0"><code class="language-html"><span class="line"><span style="color:#0008">&lt;</span><span style="color:#000">template</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">  &lt;</span><span style="color:#000">div</span><span style="color:#0008">&gt;</span><span style="color:#000">{{a}}|{{b}}</span><span style="color:#0008">&lt;/</span><span style="color:#000">div</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">  &lt;</span><span style="color:#000">button </span><span style="color:#0008">@click=</span><span style="color:#0008">"fn"</span><span style="color:#0008">&gt;</span><span style="color:#000">click</span><span style="color:#0008">&lt;/</span><span style="color:#000">button</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">&lt;/</span><span style="color:#000">template</span><span style="color:#0008">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0008">&lt;</span><span style="color:#000">script </span><span style="color:#0008">setup&gt;</span></span>
<span class="line"><span style="color:#0008">  const</span><span style="color:#000"> a </span><span style="color:#0008">=</span><span style="color:#000"> ref</span><span style="color:#0008">(</span><span style="color:#0008">''</span><span style="color:#0008">)</span></span>
<span class="line"><span style="color:#0008">  const</span><span style="color:#000"> b </span><span style="color:#0008">=</span><span style="color:#000"> ref</span><span style="color:#0008">(</span><span style="color:#0008">''</span><span style="color:#0008">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0008">  function</span><span style="color:#000;--shiki-light-font-weight:bold"> fn</span><span style="color:#0008">()</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#0008">    for</span><span style="color:#0008"> (let</span><span style="color:#000"> i </span><span style="color:#0008">=</span><span style="color:#0008"> 1;</span><span style="color:#000"> i </span><span style="color:#0008">&lt;=</span><span style="color:#0008"> 1000;</span><span style="color:#000"> i</span><span style="color:#0008">++)</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#000">      a</span><span style="color:#0008">.</span><span style="color:#000">value </span><span style="color:#0008">=</span><span style="color:#0008"> `Dom 更新, ${</span><span style="color:#000">i</span><span style="color:#0008">}`</span></span>
<span class="line"><span style="color:#000">      b</span><span style="color:#0008">.</span><span style="color:#000">value </span><span style="color:#0008">=</span><span style="color:#0008"> `Dom 更新, ${</span><span style="color:#000">i</span><span style="color:#0008">}`</span></span>
<span class="line"><span style="color:#0008">    }</span></span>
<span class="line"><span style="color:#0008">  }</span></span>
<span class="line"><span style="color:#0008">&lt;/</span><span style="color:#000">script</span><span style="color:#0008">&gt;</span></span></code></pre>
<p>意味着需要修改 <code>Dom</code> 属性 <code>1000</code> 次，这显然极其浪费性能而且是无意义的，因为对于浏览器来说在执行异步的渲染任务前即便修改了 <code>1000</code> 次 <code>Dom</code>，也只会渲染 <code>Dom 更新, 1000</code> 这最后一次修改。所以 <code>Vue</code> 内部也采用了一样的办法，异步的更新 <code>Dom</code> 属性。</p>
<h2>Vue 内部的异步更新</h2>
<p>当模板上这样展示 <code>{{ a }}</code> ，即在编译好的渲染函数中访问响应式变量 <code>a</code>， 会为 <code>a</code> 添加一个 dep，当 <code>a</code> 变更后重新执行此 <code>dep</code>。在 <a href="https://github.com/vuejs/core/blob/59e828448e7f37643cd0eaea924a764e9d314448/packages/runtime-core/src/renderer.ts#L1545" target="_blank" rel="noopener noreferrer">源码</a> 中</p>
<pre class="shiki shiki-themes Lambda Studio — Whiteout" style="background-color:#fff;color:#000" tabindex="0"><code class="language-ts"><span class="line"><span style="color:#0008">const</span><span style="color:#000;--shiki-light-font-weight:bold"> update</span><span style="color:#0008">:</span><span style="color:#000;--shiki-light-font-weight:bold"> SchedulerJob</span><span style="color:#0008"> =</span><span style="color:#0008"> ()</span><span style="color:#0008"> =&gt;</span><span style="color:#000"> effect</span><span style="color:#0008">.</span><span style="color:#000">run</span><span style="color:#0008">()</span></span>
<span class="line"><span style="color:#000">update</span><span style="color:#0008">.</span><span style="color:#000">id </span><span style="color:#0008">=</span><span style="color:#000"> instance</span><span style="color:#0008">.</span><span style="color:#000">uid</span></span>
<span class="line"><span style="color:#0008">//</span><span style="color:#0004"> create reactive effect for rendering</span></span>
<span class="line"><span style="color:#0008">const</span><span style="color:#000"> effect </span><span style="color:#0008">=</span><span style="color:#0008"> (</span><span style="color:#000">instance</span><span style="color:#0008">.</span><span style="color:#000">effect </span><span style="color:#0008">=</span><span style="color:#0008"> new</span><span style="color:#000"> ReactiveEffect</span><span style="color:#0008">(</span></span>
<span class="line"><span style="color:#000">  componentUpdateFn</span><span style="color:#0008">,</span></span>
<span class="line"><span style="color:#0008">  ()</span><span style="color:#0008"> =&gt;</span><span style="color:#000"> queueJob</span><span style="color:#0008">(</span><span style="color:#000">update</span><span style="color:#0008">),</span></span>
<span class="line"><span style="color:#000">  instance</span><span style="color:#0008">.</span><span style="color:#000">scope</span><span style="color:#0008">,</span><span style="color:#0008"> //</span><span style="color:#0004"> track it in component's effect scope</span></span>
<span class="line"><span style="color:#0008">))</span></span></code></pre>
<p>先通过 <code>new ReactiveEffect</code> 生成一个 <code>effect</code> ，传入的第一个参数会在 <code>ReactiveEffect</code> 内部保存为一个 <code>fn</code>，然后 <code>ReactiveEffect</code> 返回一个 <code>run</code> 函数，执行 <code>effect.run()</code>，就会执行内部的 <code>this.fn()</code> 即 <code>componentUpdateFn</code>，把这个 <code>effect</code> 当做 <code>dep</code> 添加到响应式变量 <code>a</code> 的 <code>deps</code> 中，<code>a</code> 变更后再执行 <code>dep.run()</code> 。但这仍然是同步更改，<code>a.value</code> 被赋值 <code>1000</code> 次，就会执行 <code>1000</code> 次 <code>componentUpdateFn</code> 。所以 <code>ReactiveEffect</code> 可以传入第二个变量，允许你自定义怎么调用 <code>effect.run()</code>，在内部保存为 <code>scheduler</code>。源码中将 <code>effect.run()</code> 传入到 <code>queueJob</code> 函数，而 <code>queueJob</code> 函数就可以异步的延迟调用 <code>effect.run()</code>。<a href="https://github.com/vuejs/core/blob/59e828448e7f37643cd0eaea924a764e9d314448/packages/runtime-core/src/scheduler.ts#LL79-L107C2" target="_blank" rel="noopener noreferrer">源码</a>：</p>
<pre class="shiki shiki-themes Lambda Studio — Whiteout" style="background-color:#fff;color:#000" tabindex="0"><code class="language-ts"><span class="line"><span style="color:#0008">export</span><span style="color:#0008"> function</span><span style="color:#000;--shiki-light-font-weight:bold"> queueJob</span><span style="color:#0008">(</span><span style="color:#000">job</span><span style="color:#0008">:</span><span style="color:#000;--shiki-light-font-weight:bold"> SchedulerJob</span><span style="color:#0008">)</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#0008">  if</span><span style="color:#0008"> (</span></span>
<span class="line"><span style="color:#0008">    !</span><span style="color:#000">queue</span><span style="color:#0008">.</span><span style="color:#000">length </span><span style="color:#0008">||</span></span>
<span class="line"><span style="color:#0008">    !</span><span style="color:#000">queue</span><span style="color:#0008">.</span><span style="color:#000">includes</span><span style="color:#0008">(</span><span style="color:#000">job</span><span style="color:#0008">,</span><span style="color:#000"> isFlushing </span><span style="color:#0008">&amp;&amp;</span><span style="color:#000"> job</span><span style="color:#0008">.</span><span style="color:#000">allowRecurse </span><span style="color:#0008">?</span><span style="color:#000"> flushIndex </span><span style="color:#0008">+</span><span style="color:#0008"> 1</span><span style="color:#0008"> :</span><span style="color:#000"> flushIndex</span><span style="color:#0008">)</span></span>
<span class="line"><span style="color:#0008">  )</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#0008">    if</span><span style="color:#0008"> (</span><span style="color:#000">job</span><span style="color:#0008">.</span><span style="color:#000">id </span><span style="color:#0008">==</span><span style="color:#0008"> null)</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#000">      queue</span><span style="color:#0008">.</span><span style="color:#000">push</span><span style="color:#0008">(</span><span style="color:#000">job</span><span style="color:#0008">)</span></span>
<span class="line"><span style="color:#0008">    }</span><span style="color:#0008"> else</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#000">      queue</span><span style="color:#0008">.</span><span style="color:#000">splice</span><span style="color:#0008">(</span><span style="color:#000">findInsertionIndex</span><span style="color:#0008">(</span><span style="color:#000">job</span><span style="color:#0008">.</span><span style="color:#000">id</span><span style="color:#0008">),</span><span style="color:#0008"> 0,</span><span style="color:#000"> job</span><span style="color:#0008">)</span></span>
<span class="line"><span style="color:#0008">    }</span></span>
<span class="line"><span style="color:#000">    queueFlush</span><span style="color:#0008">()</span></span>
<span class="line"><span style="color:#0008">  }</span></span>
<span class="line"><span style="color:#0008">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0008">function</span><span style="color:#000;--shiki-light-font-weight:bold"> queueFlush</span><span style="color:#0008">()</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#0008">  if</span><span style="color:#0008"> (!</span><span style="color:#000">isFlushing </span><span style="color:#0008">&amp;&amp;</span><span style="color:#0008"> !</span><span style="color:#000">isFlushPending</span><span style="color:#0008">)</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#000">    isFlushPending </span><span style="color:#0008">=</span><span style="color:#0008"> true</span></span>
<span class="line"><span style="color:#000">    currentFlushPromise </span><span style="color:#0008">=</span><span style="color:#000"> resolvedPromise</span><span style="color:#0008">.</span><span style="color:#000">then</span><span style="color:#0008">(</span><span style="color:#000">flushJobs</span><span style="color:#0008">)</span></span>
<span class="line"><span style="color:#0008">  }</span></span>
<span class="line"><span style="color:#0008">}</span></span></code></pre>
<p>首先 <code>effect.run()</code> 会被当做一个 <code>job</code> 传入到 <code>queueJob</code> 函数，如果 <code>a.value</code> 变更后，传入的 <code>job</code> 不在 <code>queue</code> 中，那么此 <code>job</code> 就会被添加到 <code>queue</code> 并且调用 <code>queueFlush</code> 函数，这样即便触发了 <code>1000</code> 次更新，只要 <code>queue</code> 包含这个更新，只执行一次就可以了，并且同一任务内 <code>b.value</code> 变更也不会再存入一个 <code>job</code>，因为渲染函数存入 <code>a</code> <code>b</code> 的 <code>dep</code> 是相同的。其实从这里就可以解决多次触发的问题，但是同步更新 <code>Dom</code> 可能会引起回流或者重绘，因此 <code>Vue</code> 通过 <a href="https://github.com/vuejs/core/blob/59e828448e7f37643cd0eaea924a764e9d314448/packages/runtime-core/src/scheduler.ts#L47" target="_blank" rel="noopener noreferrer">resolvedPromise</a> 创建了一个微任务，将所有的更新推迟到微任务中，一次性更新 <code>Dom</code> 。</p>
<h2>nextTick</h2>
<p>讲到这里，<code>nextTick</code> 的作用就出来了，当 <code>Vue</code> 在微任务中修改 <code>Dom</code> 属性后，在当前任务中是拿不到被修改后的 <code>Dom</code> 属性的。</p>
<pre class="shiki shiki-themes Lambda Studio — Whiteout" style="background-color:#fff;color:#000" tabindex="0"><code class="language-html"><span class="line"><span style="color:#0008">&lt;</span><span style="color:#000">template</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">  &lt;</span><span style="color:#000">div</span><span style="color:#0008">&gt;</span><span style="color:#000">{{a}}</span><span style="color:#0008">&lt;/</span><span style="color:#000">div</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">  &lt;</span><span style="color:#000">button </span><span style="color:#0008">@click=</span><span style="color:#0008">"fn"</span><span style="color:#0008">&gt;</span><span style="color:#000">click</span><span style="color:#0008">&lt;/</span><span style="color:#000">button</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">&lt;/</span><span style="color:#000">template</span><span style="color:#0008">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0008">&lt;</span><span style="color:#000">script </span><span style="color:#0008">setup&gt;</span></span>
<span class="line"><span style="color:#0008">  const</span><span style="color:#000"> a </span><span style="color:#0008">=</span><span style="color:#000"> ref</span><span style="color:#0008">(</span><span style="color:#0008">''</span><span style="color:#0008">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0008">  function</span><span style="color:#000;--shiki-light-font-weight:bold"> fn</span><span style="color:#0008">()</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#0008">    for</span><span style="color:#0008"> (let</span><span style="color:#000"> i </span><span style="color:#0008">=</span><span style="color:#0008"> 1;</span><span style="color:#000"> i </span><span style="color:#0008">&lt;=</span><span style="color:#0008"> 1000;</span><span style="color:#000"> i</span><span style="color:#0008">++)</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#000">      a</span><span style="color:#0008">.</span><span style="color:#000">value </span><span style="color:#0008">=</span><span style="color:#0008"> `Dom 更新, ${</span><span style="color:#000">i</span><span style="color:#0008">}`</span></span>
<span class="line"><span style="color:#0008">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#000">    console</span><span style="color:#0008">.</span><span style="color:#000">log</span><span style="color:#0008">(</span><span style="color:#000">document</span><span style="color:#0008">.</span><span style="color:#000">querySelector</span><span style="color:#0008">(</span><span style="color:#0008">'div'</span><span style="color:#0008">).</span><span style="color:#000">innerHTML</span><span style="color:#0008">)</span><span style="color:#0008"> //</span><span style="color:#0004"> 输出空字符串</span></span>
<span class="line"><span style="color:#000;--shiki-light-font-weight:bold">    Promise</span><span style="color:#0008">.</span><span style="color:#000">resolve</span><span style="color:#0008">().</span><span style="color:#000">then</span><span style="color:#0008">(()</span><span style="color:#0008"> =&gt;</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#000">      console</span><span style="color:#0008">.</span><span style="color:#000">log</span><span style="color:#0008">(</span><span style="color:#000">document</span><span style="color:#0008">.</span><span style="color:#000">querySelector</span><span style="color:#0008">(</span><span style="color:#0008">'div'</span><span style="color:#0008">).</span><span style="color:#000">innerHTML</span><span style="color:#0008">)</span><span style="color:#0008"> //</span><span style="color:#0004"> 输出 Dom 更新, 1</span></span>
<span class="line"><span style="color:#0008">    })</span></span>
<span class="line"><span style="color:#0008">  }</span></span>
<span class="line"><span style="color:#0008">&lt;/</span><span style="color:#000">script</span><span style="color:#0008">&gt;</span></span></code></pre>
<p><code>nextTick</code> 也是对 <code>Promise.resolve</code> 的封装</p>
<pre class="shiki shiki-themes Lambda Studio — Whiteout" style="background-color:#fff;color:#000" tabindex="0"><code class="language-ts"><span class="line"><span style="color:#0008">const</span><span style="color:#000"> resolvedPromise </span><span style="color:#0008">=</span><span style="color:#0008"> /*</span><span style="color:#0004"> #__PURE__ </span><span style="color:#0008">*/</span><span style="color:#000;--shiki-light-font-weight:bold"> Promise</span><span style="color:#0008">.</span><span style="color:#000">resolve</span><span style="color:#0008">()</span><span style="color:#0008"> as</span><span style="color:#000;--shiki-light-font-weight:bold"> Promise</span><span style="color:#0008">&lt;</span><span style="color:#000">any</span><span style="color:#0008">&gt;</span></span>
<span class="line"><span style="color:#0008">export</span><span style="color:#0008"> function</span><span style="color:#000;--shiki-light-font-weight:bold"> nextTick</span><span style="color:#0008">&lt;</span><span style="color:#000;--shiki-light-font-weight:bold">T</span><span style="color:#0008"> =</span><span style="color:#000"> void</span><span style="color:#0008">&gt;(</span><span style="color:#000">this</span><span style="color:#0008">:</span><span style="color:#000;--shiki-light-font-weight:bold"> T</span><span style="color:#0008">,</span><span style="color:#000;--shiki-light-font-weight:bold"> fn</span><span style="color:#0008">?:</span><span style="color:#0008"> (</span><span style="color:#000">this</span><span style="color:#0008">:</span><span style="color:#000;--shiki-light-font-weight:bold"> T</span><span style="color:#0008">)</span><span style="color:#0008"> =&gt;</span><span style="color:#000"> void</span><span style="color:#0008">):</span><span style="color:#000;--shiki-light-font-weight:bold"> Promise</span><span style="color:#0008">&lt;</span><span style="color:#000">void</span><span style="color:#0008">&gt;</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#0008">  const</span><span style="color:#000"> p </span><span style="color:#0008">=</span><span style="color:#000"> currentFlushPromise </span><span style="color:#0008">||</span><span style="color:#000"> resolvedPromise</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0008">  return</span><span style="color:#000"> fn </span><span style="color:#0008">?</span><span style="color:#000"> p</span><span style="color:#0008">.</span><span style="color:#000">then</span><span style="color:#0008">(</span><span style="color:#000">this </span><span style="color:#0008">?</span><span style="color:#000"> fn</span><span style="color:#0008">.</span><span style="color:#000">bind</span><span style="color:#0008">(</span><span style="color:#000">this</span><span style="color:#0008">)</span><span style="color:#0008"> :</span><span style="color:#000"> fn</span><span style="color:#0008">)</span><span style="color:#0008"> :</span><span style="color:#000"> p</span></span>
<span class="line"><span style="color:#0008">}</span></span></code></pre>
<p><code>currentFlushPromise</code> 不为空的情况下，优先使用 <code>currentFlushPromise</code>。</p>
<pre class="shiki shiki-themes Lambda Studio — Whiteout" style="background-color:#fff;color:#000" tabindex="0"><code class="language-ts"><span class="line"><span style="color:#0008">function</span><span style="color:#000;--shiki-light-font-weight:bold"> queueFlush</span><span style="color:#0008">()</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#0008">  if</span><span style="color:#0008"> (!</span><span style="color:#000">isFlushing </span><span style="color:#0008">&amp;&amp;</span><span style="color:#0008"> !</span><span style="color:#000">isFlushPending</span><span style="color:#0008">)</span><span style="color:#0008"> {</span></span>
<span class="line"><span style="color:#000">    isFlushPending </span><span style="color:#0008">=</span><span style="color:#0008"> true</span></span>
<span class="line"><span style="color:#000">    currentFlushPromise </span><span style="color:#0008">=</span><span style="color:#000"> resolvedPromise</span><span style="color:#0008">.</span><span style="color:#000">then</span><span style="color:#0008">(</span><span style="color:#000">flushJobs</span><span style="color:#0008">)</span></span>
<span class="line"><span style="color:#0008">  }</span></span>
<span class="line"><span style="color:#0008">}</span></span></code></pre>
<p><code>currentFlushPromise</code> 被赋值为一个 <code>promise</code>，当 <code>flushJobs</code> 函数执行完后，也就是 <code>Dom</code> 属性更新完后就会执行 <code>nextTick</code> 的回调，而在这个回调函数中就可以得到被修改后的 <code>Dom</code> 属性值。</p>
</div></div></div></main></div>
  

</body></html>